# AXI3

## 1、AXI features

AXI引入了**通道(channel)**的概念，AXI总线共有**5个独立的通道**：**写地址、写数据、写回应、读地址、读数据通道**。所谓的通道，其实就是一组信号而已。可以类比AHB，AHB可以认为有控制、写数据、读数据通道。

![img](D:\lqh\Typora\图片\v2-b3d7ebc12e03ddda1e98a28e46113656_720w.webp)

AXI主要有以下的特性：

- **独立的读、写通道**：上面提到AXI有 5 个独立的通道，我们还可以**更粗略的分为读写两个通道**，其中读通道由读地址通道加读数据通道组成；写通道由写地址通道加写数据通道加写响应通道组成，如下图所示，AXI总线支持同时读写，光这一点就比AHB不知道高到哪里去了。

![img](D:\lqh\Typora\图片\v2-5276f632afefcb4b2cab7779f4fd06dd_720w.webp)

- **支持Outstanding操作**：所谓的Outstanding，即“**在路上**”，以读为例，AHB读回了数据才可以发起下一次读请求，但是AXI允许读数据返回之前，又发起一次新的读请求，最大允许多少次读请求在路上，由Outstanding Num决定。

举个生活的例子，比如开车去某个地方拿东西，需要使用马路，AHB则只允许马路上有一辆车，这辆车拿回了东西以后才允许新的车驶向马路。而AXI则允许马路上有很多同向的车，如上图所示，有三辆绿车可以同时驶入大马路。
这个机制非常的好呀，尤其是延迟较大的情况下，可以做到不影响带宽，将延迟掩盖起来。这个概念跟CPU的流水线也很类似，大家可以类比着学习（多条指令在并行，而不用等待一条指令执行完成再执行下一条指令）。

- **写地址和写数据之间的关系较为灵活**：前面我们学习的AHB协议的写数据必须位于写地址的下一拍，设计起来其实存在很多的限制。而AXI采用的是握手机制，并且写地址和写数据并没有明确的要求哪个在前哪个在后，非常的灵活，用起来非常的爽。（具体什么是握手机制后面再讲）
- **支持非对齐传输**：当我们谈论对齐传输的时候，一般指的是字对齐，即32bit对齐。对于具体的某一bit的地址，比如0x00，它只能存8bit的数据，想要存32bit的数据需要用到0x00~0x03这4个地址。之前学的AHB协议只允许访问0x00、0x04、0x08之类的地址。而AXI是允许访问0x01之类的地址的，也就是允许非对齐访问。

![img](D:\lqh\Typora\图片\v2-2a95c47b92cfb13cf5b509a953fb121e_720w.webp)

- **支持乱序传输**：乱序传输的核心是ID号。
  - **以读操作举例说明**，AXI的读顺序涉及到的信号为ARID和RID，ARID来自主设备，RID来自从设备。对于主设备而言， 同一个ARID序号需要按照发射顺序返回读取的值，即**<u>同一个ID应该要求保序</u>**。而不同的ARID序号可以以任意顺序返回值，即<u>**不同ID可以乱序**</u>。比如我发了一个ARID为1的请求，又发了一个ARID为2的读请求。是可以先返回ARID为2的读请求所要的读数据的，相应的RID应该也为2，用来说明对应关系。
  - **对于写操作而言**，AXI写顺序涉及到的信号为AWID和BID（WID在AXI4中移除），也是**<u>同一ID必须保序，不同ID可以乱序</u>**。比如我发起了AWID为1的写请求，又发起了AWID为2的写请求，BID为2是可以先回来的，说明AWID为2的写请求已经写完成了，这个是允许的。具体的实例后面再讲解，这一部分也是AXI设计中相对较为复杂的点，实际上很多SoC实现的是阉割版的AXI协议，不支持乱序传输。是否需要支持该feature还是取决于具体应用场景。

![img](D:\lqh\Typora\图片\v2-f1cf1d7f90dce10b2ae1295d691c5cde_720w.webp)

- **Burst操作只需要提供首地址**：每次传输数据，不需要像AHB一样，每次传输都给相应的地址，只需要在第一次传输的时候给出首地址即可。

## 2、AXI的典型应用场景

如下图所示，是一个典型的基于AXI总线的SoC。其使用的场景相较于AHB总线而言更高端，**跑的主频一般也更高**。掌握AXI总线对于找工作而言非常重要，现在基本所有的公司都要求掌握AXI总线，此外AXI总线的设计思想对设计其它的模块也很有帮助。大家需要好好学习

![img](D:\lqh\Typora\图片\v2-34141feb903f54d202854a0e864edc75_720w.webp)

## 3、AXI握手机制（非常重要！）

### 3.1、握手机制和信号列表

握手这个机制，听名字就知道需要双方的参与，ARM官方是这么说的：作为一种[双向](https://www.zhihu.com/search?q=双向流控机制&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"44766356"})流控机制，**VALID**/**READY** 机制可以使发送接收双方都有能力控制传输速率。在握手机制中，有SOURCE端和DESTINATION端，即源端和目的端。

源端通过**VALID**信号来标志信息是有效的，目的端使用**READY**信号来标志有能力接收更多的信息。**VALID一旦拉高，在完成握手之前是不允许改变的！握手成功代表这个通道的通信完成。**

| 数据通路   | 握手信号对       |
| ---------- | ---------------- |
| 写地址通路 | AWVALID, AWREADY |
| 写数据通路 | WVALID, WREADY   |
| 写回应通路 | BVALID, BREADY   |
| 读地址通路 | ARVALID, ARREADY |
| 读数据通路 | RVALID, RREADY   |

### 3.2、握手过程

在AXI协议中，因为有五个通道，与之对应的双向握手信号合计十个。这些信号的握手标志了传输的进行。顺着握手，我们可以引申出三种情况。

**<u>VALID信号先于READY信号改变</u>**：如下图所示，在T1~T2这个时段Master已经拉高了VALID，拉高了VALID代表它已经准备好给Slave数据了，但是Slave因为各种各样的原因，此时并没有准备好接收数据。那怎么办？那就只能等啊，一直到T3时刻的上升沿，**同时采样到VALID和READY都为高，说明握手成功**，Master成功把数据传输给了Slave，然后二者需要同时拉低(**握手成功后VALID必须拉低**，READY可以保持为高，表示SLAVE可以继续接收数据)。![img](D:\lqh\Typora\图片\v2-ecc2d7b8bffbee5196f288c43d60d322_720w.webp)

**这种情况下，Master的VALID是不允许中途拉低的**，这是协议硬性规定的，**一旦拉高，就必须等待握手成功才允许拉低**。**<u>此外VALID是不可以依赖于READY的</u>**，不能说READY拉高VALID再拉高，体现在具体的设计中实际上是不能允许将READY作为逻辑输入，生成VALID信号。要不然有可能造成死锁的状况（组合逻辑、FIFO、打拍都不允许，简而言之就是VALID的生成信号不能包含READY）。因为**实际上READY是可以依赖于VALID的，**如果VALID再依赖于READY，那么如果VALID不拉高，READY也不拉高，那么VALID也不拉高，那么.....

**<u>VALID和READY同时拉高</u>**：这种情况非常的棒，直接采样完成通信，二者再同时拉低即可。<img src="D:\lqh\Typora\图片\v2-cd87a970a39acd19d18d79930a38c4f3_720w.webp" alt="img" style="zoom:150%;" />

**<u>READY先于VALID拉高</u>**：这种情况也很常见，比如Slave的READY信号是默认拉高的，代表随时可以准备采样，如下图的T2时刻，VALID还没有拉高，则没有进行采样，T3时刻均为高，完成握手，数据发生传输。那么READY拉高以后可以中间拉低吗？实际上也是可以的，协议没有规定不允许，但这种情况很少见。![img](D:\lqh\Typora\图片\v2-60bf4b79385786830cbf55bd57022432_720w.webp)

### 3.3、不同数据通道间的先后顺序

**不同通道之间的也是存在约束关系的**，这些约束关系非常的直观，首先讨论**读操作**。

**<u>读操作</u>**本身有两个通道，读地址通道和读数据通道。下图中的双箭头表示一定要在此之后，单箭头表示先后关系都可以。我们可以看到，通道内部之间是谁先谁后都无所谓的，这就是开始说的VALID和READY，谁先谁后都可以。**但是读数据通道必须在读地址通道之后，其实非常好理解，你地址都没给，你读啥数据呢？**不知道地址，Slave那边不知道回什么数据，它还必须等你的读地址通道的数据，才知道给哪个地址的数，这就存在依赖关系了，设计不好就会造成死锁。为了避免这个问题，AXI协议索性规定了硬性的先后顺序。<img src="D:\lqh\Typora\图片\image-20240116105751638.png" alt="image-20240116105751638" style="zoom:150%;" />

**<u>写操作</u>**有3个通道，对于写地址和写数据而言，谁先谁后是无所谓的，你可以先给地址再给数据，或者先给数据再给地址。（但是很多IP在设计的时候，为了简便考虑，仍然规定写地址通道在写数据通道之前），但是写回复通道必须在写地址和写数据通道之后，BVALID是SLAVE发给MASTER的，如果没给地址和数据，SLAVE没法完成写操作，不可能先发BVALID。

------------**NOTE**------------

AXI3中，即使不给写地址，只给了写数据，也是可以有response的，但是这样需要Buffer存储，进而导致设计复杂。因此在AXI4中规定必须写地址通道和写数据通道全部都给了以后，才可以进行response。

------------------------------

![img](D:\lqh\Typora\图片\v2-29456bf72c865f899120e5831be6df9f_720w.webp)

## 4、Transfer和Transaction的区别

简单来说，**一次传输即握手成功就叫做一次transfe**r，有些场景也会叫做一次beat。而Transaction指的是传输一组数据所发生的所有的交互。用官方的话来说如下：

- A transfer is a single exchange of information, with one VALID and READY handshake.
- A transaction is an entire burst of transfers, containing an address transfer, one or more data transfers, and, for write sequences, a response transfer.

![img](D:\lqh\Typora\图片\v2-443c135585151f894aa027e3a7a9c5c9_720w.webp)

